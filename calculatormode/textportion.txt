https://docs.google.com/document/d/1eFU7rszOy7nNaFcwYVmtUqZ3X3j0hu2RnRRXkRyw-3Y/edit?usp=sharing	
    
    In the work section of this project, an attempt to build a calculator is made. It is in relation to a reverse polish notation (RPN) calculator; of which we also attempted to build in a prior project. The primary difference between the RPN calculator, and this object calculator, lies in that keyword, “object.” As established in previous papers, modern programming typically chooses and follows between three commonly accepted paradigms (methods by which to create a finished product), and for this assignment, we are to use ‘object-oriented programming’ (OOP).
	Object, in programming, can be considered a loaded term. Perhaps, as I learned from unixdigest.com, in their article exploring the programming language Golang, objects are better understood when we look at the past of programming. The goal of innovating programming paradigms arose from a need to organize, categorize, and effectively reuse information across many lines of code, often spanning across many files, and many machines. With all these connections being made, eventually, it became useful to obfuscate information from certain programs, and allow others to see it. As a result, a concept of “objects” was made, that being, a structure which can limit the scope of your program. Limiting the scope is to intentionally obscure data and info from the computer, while allowing certain “roads-in and out” for transferring that info.
	My instructor taught objects to me as towns with tall walls; they are isolated, and there are often predetermined routes through the town/object. For instance, a town may have walls, a road in, and a road out. This town may take in raw iron through the intake, and may output goods of iron through the road out. 
In a more technical, less abstract manner of speaking, an object of type class may be made. It will have a private and a public area. That which is inside of its private area is obfuscated from anything outside of the object, and cannot reach outside of the class. That which is in the public area can access the private section of this class, as well as have access to the rest of the program. An non-functioning but relatively understandable example is provided, illustrating the separation inside the class between public and private.
	In our last calculator, we had to reassign number values of integers (9999, 8888,) to operations (add, subtract,) to create our operators, because the functions of our calculator really only handled numbers. However, part of this was the construction of a unique “complex type” called a struct. A struct can be many things, however, the easiest way I’ve found to illustrate the concept of a complex type is with the lunchbox method. Primitive types (characters, integers, booleans, and sets) are like… one thing, right? A set of characters can be changed into any other set of characters, but it cannot be changed into any set of integers or whatever without using mapping or casting. 
You can picture primitives types as a tray with one thing on them. It has one character, (“A”) contained within the tray.
Using complex types, we can send evaluation data in the form of actual operators into the calculator instead of having to cast integers to our operations like before.
